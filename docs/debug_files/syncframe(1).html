<!DOCTYPE html>
<!-- saved from url=(0762)https://gum.criteo.com/syncframe?origin=publishertag&topUrl=search.yahoo.co.jp#{%22lwid%22:{%22origin%22:0},%22bundle%22:{%22value%22:%22Np0lp183Qzh3NkloSVk5NkE1MHRreDNlWmYxaGhhV05IQVBZTktnQjFGM2pPWjFRZSUyRm5aMUZ1c2ZNcVZsNGNSMyUyQjdGSnpnUzQwVlAlMkJNb1VkSnBkRjVTZ0lIUG5iYU91UHpPeXVMajdjQiUyQnZabEclMkZJdzM1cDh2Tk1BV2ZBeUE4RUtPR2pXUTRndVpVYzRLamhvc2R3ZjltNXV6YkJXZkxuZUpEWGJqZWhtMXVheXhId3RMeWhTJTJCZ2w0dFJ6b1c5RHVVSVFIZWtCTSUyQkxhajRCNkdqSnAyTm1DUEtia2E0eiUyRnBLNTJ5Q2lBWUJlS2toJTJGUEl6TjdZb041UzNBT29LOGhlOWVV%22,%22origin%22:2},%22optout%22:{%22value%22:false,%22origin%22:0},%22tld%22:%22s.yimg.jp%22,%22topUrl%22:%22search.yahoo.co.jp%22,%22version%22:150,%22cw%22:false,%22lsw%22:true,%22origin%22:%22publishertag%22,%22requestId%22:%220.1335520025738537%22} -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/javascript">
        window.CONFIG_CSM_DOMAIN_NAME = "csm.jp2.as.criteo.net";
        window.CONFIG_CSM_RATIO = 100;
        window.GUM_DOMAIN = "gum.criteo.com";
    </script>
    <script type="text/javascript">
        !function(){"use strict";var i=function(t,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};function t(t,e){function n(){this.constructor=t}i(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var e=function(){return(e=Object.assign||function(t){for(var e,n=1,i=arguments.length;n<i;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function n(r,s,a,l){return new(a=a||Promise)(function(t,e){function n(t){try{o(l.next(t))}catch(t){e(t)}}function i(t){try{o(l.throw(t))}catch(t){e(t)}}function o(e){e.done?t(e.value):new a(function(t){t(e.value)}).then(n,i)}o((l=l.apply(r,s||[])).next())})}function s(n,i){var o,r,s,t,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return t={next:e(0),throw:e(1),return:e(2)},"function"==typeof Symbol&&(t[Symbol.iterator]=function(){return this}),t;function e(e){return function(t){return function(e){if(o)throw new TypeError("Generator is already executing.");for(;a;)try{if(o=1,r&&(s=2&e[0]?r.return:e[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,e[1])).done)return s;switch(r=0,s&&(e=[2&e[0],s.value]),e[0]){case 0:case 1:s=e;break;case 4:return a.label++,{value:e[1],done:!1};case 5:a.label++,r=e[1],e=[0];continue;case 7:e=a.ops.pop(),a.trys.pop();continue;default:if(!(s=0<(s=a.trys).length&&s[s.length-1])&&(6===e[0]||2===e[0])){a=0;continue}if(3===e[0]&&(!s||e[1]>s[0]&&e[1]<s[3])){a.label=e[1];break}if(6===e[0]&&a.label<s[1]){a.label=s[1],s=e;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(e);break}s[2]&&a.ops.pop(),a.trys.pop();continue}e=i.call(n,a)}catch(t){e=[6,t],r=0}finally{o=s=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}([e,t])}}}function a(t,e){if(!function(t){try{return void 0!==t.cookie}catch(t){return!1}}(t))return null;for(var n=t.cookie.split(";"),i=0;i<n.length;i++){var o=n[i],r=o.substr(0,o.indexOf("=")).replace(/^\s+|\s+$/g,""),s=o.substr(o.indexOf("=")+1);if(r===e&&s)return decodeURIComponent(s)}return null}var o=(r.prototype.logCounter=function(t){var e="entry=c~"+(this.METRIC_PREFIX?this.METRIC_PREFIX+".":"")+(t||"")+"~1";this._eventsQueue.push(e)},r.prototype.logHistogram=function(t,e){var n="entry=h~"+(this.METRIC_PREFIX?this.METRIC_PREFIX+".":"")+(t||"")+"~"+e;this._eventsQueue.push(n)},r.prototype.logError=function(t,e,n){void 0===n&&(n=null);var i=e&&e.message||e,o="string"==typeof n?[n]:n,r=[this.METRIC_PREFIX,t].concat(o).reduce(function(t,e){return t.concat(e&&e.split(".")||[])},[]).filter(function(t){return null!=t&&null!=t&&""!=t}).map(function(t){return"&tag="+encodeURIComponent(t)}).join(""),s="https://"+this.CSM_BASE_DOMAIN+"/iex?gPath="+(this.METRIC_PREFIX?this.METRIC_PREFIX+".":"")+encodeURIComponent(t)+"&msg="+encodeURIComponent(i)+r;this.logPixel(s)},r.prototype.sendMetrics=function(){this.flushEventQueue()},r.prototype.flushEventQueue=function(){if(0<this._eventsQueue.length){var t="https://"+this.CSM_BASE_DOMAIN+"/iev?"+this._eventsQueue.join("&");this.logPixel(t),this._eventsQueue=[]}},r.prototype.logPixel=function(t){if(!this.CSM_BASE_DOMAIN)return console.log("Pixel",t);var e=Math.floor(100*Math.random());this.SAMPLING_RATIO<=e||("function"==typeof navigator.sendBeacon?navigator.sendBeacon(t):(new Image).src=t)},r);function r(t,e,n){var i=this;void 0===e&&(e=""),void 0===n&&(n=100),this._eventsQueue=[],this.CSM_BASE_DOMAIN=t,this.SAMPLING_RATIO=n||100,this.METRIC_PREFIX=e||"",window.addEventListener("pagehide",function(){return i.flushEventQueue()})}var l=(u.prototype.sendSidJson=function(t){var e=this,n=u.buildUrl(this._sidUrlBase,t),i=Date.now();return fetch(n,{credentials:"include"}).then(function(t){return t.json()}).then(function(t){return e.csmClient.logCounter("SidReadSuccess"),e.csmClient.logHistogram("SidReadSuccessDuration",Date.now()-i),t}).catch(function(t){return e.csmClient.logCounter("SidReadFailure"),e.csmClient.logHistogram("SidReadFailureDuration",Date.now()-i),e.csmClient.logError("SidReadError",t),{}})},u.buildUrl=function(t,e){var n,i,o,r,s=window.location.ancestorOrigins&&window.location.ancestorOrigins[0]?window.location.ancestorOrigins[0]:null,a=s?new URL(s):null,l=a?a.hostname:"",u=e.fragmentData,c=e.topUrl||u.topUrl,d=e.privateModeStatus||u.pm,h=u.syncframeOverrideVersion||e.syncframeVersion,p=null!==(i=null===(n=e.delegationCookies)||void 0===n?void 0:n.bundle)&&void 0!==i?i:u.bundle,f=null!==(r=null===(o=e.delegationCookies)||void 0===o?void 0:o.optout)&&void 0!==r?r:u.optout;return t+"?origin="+u.origin+(h?"&v="+h:"")+"&domain="+encodeURIComponent(u.tld?u.tld:l)+"&sn="+e.syncframeName+"&so="+p.origin+(c?"&topUrl="+encodeURIComponent(c):"")+(u.lwid.hasValue()?"&lwid="+encodeURIComponent(u.lwid.value):"")+(p.hasValue()?"&bundle="+encodeURIComponent(p.value):"")+(e.dnaBundle?"&info="+encodeURIComponent(e.dnaBundle):"")+(e.dnsIdChunks&&e.dnsIdChunks.length?"&idsd="+e.dnsIdChunks.toString():"")+(d?"&pm="+d:"")+(u.cookiesWriteable?"&cw=1":"")+(f.hasValue()&&f.value?"&optout=1":"")+(u.rtusCallerId?"&rtusCallerId="+u.rtusCallerId:"")+(u.localStorageWritable?"&lsw=1":"")+(e.interestBasedAdvertising?"&topicsavail="+(e.interestBasedAdvertising.topicsApiAvailable?"1":"0"):"")+(e.interestBasedAdvertising?"&fledgeavail="+(e.interestBasedAdvertising.fledgeApiAvailable?"1":"0"):"")+(e.interestBasedAdvertising?e.interestBasedAdvertising.rawTopics.map(function(t){return"&topic="+encodeURIComponent(t)}).join(""):"")+(window.DEBUG?"&debug=1":"")},u);function u(t,e){this.csmClient=e,this._sidUrlBase="https://"+t+"/sid/json"}var c=(d.prototype.start=function(){return n(this,void 0,void 0,function(){var e,n;return s(this,function(t){switch(t.label){case 0:return[4,this.performCall()];case 1:return(e=t.sent()).info?[2,e]:[4,this.performCall()];case 2:return(n=t.sent()).info?this.csmClient.logCounter("StorageWriting.Dna.Success"):this.csmClient.logCounter("StorageWriting.Dna.Failure"),[2,n]}})})},d.prototype.performCall=function(){return n(this,void 0,void 0,function(){return s(this,function(t){switch(t.label){case 0:return[4,fetch(this.dnaDomain,{credentials:"include"}).then(function(t){return t.json()}).catch(function(t){return{info:null}})];case 1:return[2,t.sent()]}})})},d);function d(t,e){this.dnaDomain=t,this.csmClient=e}var f,h,g,p,v=(m.prototype.readAll=function(){return n(this,void 0,void 0,function(){return s(this,function(t){switch(t.label){case 0:return this.dnsIdEnabled?[4,Promise.all(this.dnsIdDomainList.map(this.read))]:[2,[]];case 1:return[2,t.sent().map(function(t){return t.idsd})]}})})},m.prototype.read=function(e){return n(this,void 0,void 0,function(){return s(this,function(t){switch(t.label){case 0:return[4,fetch("https://"+e+"/newidsd").then(function(t){return t.json()}).catch(function(t){return{idsd:-2}})];case 1:return[2,t.sent()]}})})},m);function m(t,e){this.dnsIdEnabled=t,this.dnsIdDomainList=e}(h=f=f||{})[h.None=0]="None",h[h.Cookie=1]="Cookie",h[h.LocalStorage=2]="LocalStorage",h[h.Delegation=4]="Delegation",(p=g=g||{})[p.Unknown=0]="Unknown",p[p.Deactivated=1]="Deactivated",p[p.Activated=2]="Activated";var C=(w.fromUserIdentificationData=function(t){return new w(t.value,t.origin)},w.fromValue=function(t){return new w(t,f.None)},w.prototype.hasValue=function(){return""!==String(this.value)&&null!==this.value&&void 0!==this.value},w);function w(t,e){this.value=t,this.origin=e}var I;t(y,I=C),y.prototype.hasValue=function(){return""!==String(this.value)&&null!==this.value&&void 0!==this.value},y.prototype.saveOnAllStorages=function(){if(this.hasValue()){var t="boolean"==typeof this.value?this.value?"1":"0":String(this.value);this.storageAdapter.writeToAllStorages(this.storageKey,t,this.expirationTimeHours)}},y.prototype.toJSON=function(){return{value:this.value,origin:this.origin}};function y(t,e,n,i,o){var r=I.call(this,n,i)||this;return r.storageKey=t,r.expirationTimeHours=e,r.storageAdapter=o,r}var b=(A.prototype.isEmpty=function(){return!(this.bundle||this.optout)},A);function A(t,e){this.bundle=t?new C(t,f.Delegation):void 0,this.optout=e?new C("1"===e,f.Delegation):void 0}var T=(D.prototype.read=function(){return n(this,void 0,void 0,function(){return s(this,function(t){switch(t.label){case 0:return this.hasToReadOnDelegatedSubdomain()?[4,fetch(this.delegationUrl,{credentials:"include"}).then(function(t){return t.json()}).then(function(t){return new b(t.cto_bundle,t.cto_optout)}).catch(function(t){return null})]:[3,2];case 1:return[2,t.sent()];case 2:return[2,new b]}})})},D.prototype.hasToReadOnDelegatedSubdomain=function(){return this.readCookiesOnDelegatedSubdomain&&this.delegationUrl},D);function D(t,e){this.delegationUrl=t,this.readCookiesOnDelegatedSubdomain=e}var _=(O.Create=function(t){var e,n,i,o,r,s,a,l,u,c,d={lwid:{value:null,origin:f.None},bundle:{value:null,origin:f.None},optout:{value:null,origin:f.None},tld:"",topUrl:"",version:"NA",cw:!1,lsw:!1,origin:"NA",pm:g.Unknown,rtusCallerId:void 0,osv:void 0,requestId:"ignored"};try{var h=location.hash.substring(1);"{%22"===h.substr(0,4)&&(h=decodeURIComponent(h)),c=JSON.parse(h)}catch(t){c=d}function p(t){var e,n=null!==(e=c[t])&&void 0!==e?e:d[t];return"object"==typeof n?C.fromUserIdentificationData(n):C.fromValue(n)}return new O(p("lwid"),p("optout"),p("bundle"),null!==(e=c.osv)&&void 0!==e?e:d.osv,null!==(n=c.tld)&&void 0!==n?n:d.tld,null!==(i=c.origin)&&void 0!==i?i:d.origin,String(null!==(o=c.version)&&void 0!==o?o:d.version),decodeURIComponent(null!==(r=c.topUrl)&&void 0!==r?r:d.topUrl),null!==(s=c.pm)&&void 0!==s?s:d.pm,null!==(a=c.cw)&&void 0!==a?a:d.cw,t,null!==(l=c.rtusCallerId)&&void 0!==l?l:d.rtusCallerId,null!==(u=c.lsw)&&void 0!==u?u:d.lsw,c.requestId)},O.prototype.emitCsmMetrics=function(){this.lwid.hasValue()&&this.csmClient.logCounter("FragmentData."+this.origin+".Lwid.Origin."+this.lwid.origin),this.optout.value&&this.csmClient.logCounter("FragmentData."+this.origin+".Optout.Origin."+this.optout.origin),this.bundle.hasValue()&&this.csmClient.logCounter("FragmentData."+this.origin+".Bundle.Origin."+this.bundle.origin),this.pm&&this.csmClient.logCounter("FragmentData."+this.origin+".PrivateMode.Origin."+this.pm)},O);function O(t,e,n,i,o,r,s,a,l,u,c,d,h,p){this.lwid=t,this.optout=e,this.bundle=n,this.syncframeOverrideVersion=i,this.tld=o,this.origin=r,this.version=s,this.topUrl=a,this.pm=l,this.cookiesWriteable=u,this.csmClient=c,this.rtusCallerId=d,this.localStorageWritable=h,this.requestId=p}var R=(S.prototype.getFragmentData=function(){return null==this.fragmentData&&(this.fragmentData=_.Create(this.getCsmClient())),this.fragmentData},S.prototype.getCsmClient=function(){return null==this.csmClient&&(this.csmClient=new o(this.window.CONFIG_CSM_DOMAIN_NAME,"Gum."+this.syncframeName,window.CONFIG_CSM_RATIO)),this.csmClient},S.prototype.getSidClient=function(t){return null==this.sidClient&&(this.sidClient=new l(t||this.window.GUM_DOMAIN,this.getCsmClient())),this.sidClient},S.prototype.getDnaClient=function(){return null==this.dnaClient&&(this.dnaClient=new c(window.DNA_DOMAIN,this.getCsmClient())),this.dnaClient},S.prototype.getDnsIdClient=function(){return null==this.dnsIdClient&&(this.dnsIdClient=new v(this.window.DNSID_ENABLED,window.DNSID_DOMAIN_LIST)),this.dnsIdClient},S.prototype.getDelegationClient=function(){return null==this.delegationClient&&(this.delegationClient=new T(this.window.DELEGATION_URI,this.window.READ_FROM_SUBDOMAIN_DELEGATION||!1)),this.delegationClient},S.prototype.postMessageToCaller=function(t){!function(t,e){e.parent.postMessage(t,"*")}(e(e({},t),{requestId:this.getFragmentData().requestId}),window)},S);function S(t,e){this.syncframeName=t,this.window=e}var E,M=(N.prototype.getInterestBasedAdvertising=function(){return n(this,void 0,void 0,function(){var e,n,i,o;return s(this,function(t){switch(t.label){case 0:return e="browsingTopics"in this.document,n="runAdAuction"in this.navigator,e?[4,this.document.browsingTopics()]:[2,{topicsApiAvailable:e,rawTopics:[],fledgeApiAvailable:n}];case 1:return i=t.sent(),o=i.map(function(t){var e=t.topic,n=t.version;return JSON.stringify({topic:e,version:n})}),[2,{topicsApiAvailable:e,rawTopics:o,fledgeApiAvailable:n}]}})})},N.prototype.addTrialTokens=function(){this.isTrialTokenDropped||(this.addTrialToken(N.CRITEO_COM_FIRST_PARTY_TOKEN),this.addTrialToken(N.CRITEO_COM_THIRD_PARTY_TOKEN),this.isTrialTokenDropped=!0)},N.prototype.addTrialToken=function(t){var e=document.createElement("meta");e.httpEquiv="origin-trial",e.content=t,this.document.head.appendChild(e)},N.CRITEO_COM_THIRD_PARTY_TOKEN="AzLNuh8GFzfIOcwvhEg7Ymr7YCzlYVTKeD7i2iETABbRf+sL2FAx+r+HlTtxSi1zgUFxBlJVoxgLjuhqiwTjAw4AAACAeyJvcmlnaW4iOiJodHRwczovL2NyaXRlby5jb206NDQzIiwiZmVhdHVyZSI6IlByaXZhY3lTYW5kYm94QWRzQVBJcyIsImV4cGlyeSI6MTY4MDY1Mjc5OSwiaXNTdWJkb21haW4iOnRydWUsImlzVGhpcmRQYXJ0eSI6dHJ1ZX0=",N.CRITEO_COM_FIRST_PARTY_TOKEN="At+JrxwMJ+2ydeTHGTI0QTHyXmvnCiq6yo2C8re8ZBtETdIUCVuWzBE9AnMWGF3vcV14mhw8ff87NOP5/ibffggAAABseyJvcmlnaW4iOiJodHRwczovL2NyaXRlby5jb206NDQzIiwiZmVhdHVyZSI6IlByaXZhY3lTYW5kYm94QWRzQVBJcyIsImV4cGlyeSI6MTY4MDY1Mjc5OSwiaXNTdWJkb21haW4iOnRydWV9",N);function N(t,e){this.isTrialTokenDropped=!1,this.document=t,this.navigator=e,this.addTrialTokens()}function U(){return E.call(this,"ChromeSyncframe",window)||this}(new(t(U,E=R),U.prototype.Start=function(){return n(this,void 0,void 0,function(){var e,n,i,o,r;return s(this,function(t){switch(t.label){case 0:return t.trys.push([0,3,,4]),e=function(){var t=a(document,"optout");return{uid:a(document,"uid"),optout:"1"===t||null}}(),n=this.getFragmentData(),this.logCookieMetrics(e),n.emitCsmMetrics(),[4,new M(this.window.document,this.window.navigator).getInterestBasedAdvertising()];case 1:return i=t.sent(),[4,this.getSidClient().sendSidJson({fragmentData:n,syncframeName:this.syncframeName,interestBasedAdvertising:i})];case 2:return o=t.sent(),this.postMessageToCaller({isCriteoMessage:!0,optout:e.optout||o.optout,bundle:o.bundle}),[3,4];case 3:return r=t.sent(),this.getCsmClient().logError("GlobalError",r),[3,4];case 4:return[2]}})})},U.prototype.logCookieMetrics=function(t){for(var e=0,n=Object.keys(t);e<n.length;e++){var i=n[e];t[i]&&this.getCsmClient().logCounter("CookieRead."+i)}},U)).Start()}();

    </script><meta http-equiv="origin-trial" content="At+JrxwMJ+2ydeTHGTI0QTHyXmvnCiq6yo2C8re8ZBtETdIUCVuWzBE9AnMWGF3vcV14mhw8ff87NOP5/ibffggAAABseyJvcmlnaW4iOiJodHRwczovL2NyaXRlby5jb206NDQzIiwiZmVhdHVyZSI6IlByaXZhY3lTYW5kYm94QWRzQVBJcyIsImV4cGlyeSI6MTY4MDY1Mjc5OSwiaXNTdWJkb21haW4iOnRydWV9"><meta http-equiv="origin-trial" content="AzLNuh8GFzfIOcwvhEg7Ymr7YCzlYVTKeD7i2iETABbRf+sL2FAx+r+HlTtxSi1zgUFxBlJVoxgLjuhqiwTjAw4AAACAeyJvcmlnaW4iOiJodHRwczovL2NyaXRlby5jb206NDQzIiwiZmVhdHVyZSI6IlByaXZhY3lTYW5kYm94QWRzQVBJcyIsImV4cGlyeSI6MTY4MDY1Mjc5OSwiaXNTdWJkb21haW4iOnRydWUsImlzVGhpcmRQYXJ0eSI6dHJ1ZX0=">
<script type="text/javascript" src="chrome-extension://mdnleldcmiljblolnjhpnblkcekpdkpa/libs/customElements.js" class="__REQUESTLY__SCRIPT"></script><script type="text/javascript" class="__REQUESTLY__SCRIPT">((namespace) => {
  const RuleSourceKey = {
    URL: "Url",
    HOST: "host",
    PATH: "path",
  };

  const RuleSourceOperator = {
    EQUALS: "Equals",
    CONTAINS: "Contains",
    MATCHES: "Matches",
    WILDCARD_MATCHES: "Wildcard_Matches",
  };

  const toRegex = (regexStr) => {
    const matchRegExp = regexStr.match(new RegExp("^/(.+)/(|i|g|ig|gi)$"));

    if (!matchRegExp) {
      return null;
    }

    try {
      return new RegExp(matchRegExp[1], matchRegExp[2]);
    } catch {
      return null;
    }
  };

  const checkRegexMatch = (regexString, inputString) => {
    if (!regexString.startsWith("/")) {
      regexString = `/${regexString}/`; // Keeping enclosing slashes for regex as optional
    }

    const regex = toRegex(regexString);
    return regex?.test(inputString);
  };

  const checkWildCardMatch = (wildCardString, inputString) => {
    const regexString = "/^" + wildCardString.replaceAll("*", ".*") + "$/";
    return checkRegexMatch(regexString, inputString);
  };

  const extractUrlComponent = (url, key) => {
    const urlObj = new URL(url);

    switch (key) {
      case RuleSourceKey.URL:
        return url;
      case RuleSourceKey.HOST:
        return urlObj.host;
      case RuleSourceKey.PATH:
        return urlObj.pathname;
    }
  };

  window[namespace] = window[namespace] || {};
  window[namespace].matchSourceUrl = (sourceObject, url) => {
    const urlComponent = extractUrlComponent(url, sourceObject.key);
    const value = sourceObject.value;

    if (!urlComponent) {
      return false;
    }

    switch (sourceObject.operator) {
      case RuleSourceOperator.EQUALS:
        if (value === urlComponent) {
          return true;
        }
        break;

      case RuleSourceOperator.CONTAINS:
        if (urlComponent.indexOf(value) !== -1) {
          return true;
        }
        break;

      case RuleSourceOperator.MATCHES: {
        return checkRegexMatch(value, urlComponent);
      }

      case RuleSourceOperator.WILDCARD_MATCHES: {
        return checkWildCardMatch(value, urlComponent);
      }
    }

    return false;
  };
})('__REQUESTLY__')</script><script type="text/javascript" class="__REQUESTLY__SCRIPT">(function ({
  namespace,
  customHeaderPrefix = "",
  ignoredHeadersOnRedirect = [],
}) {
  window[namespace] = window[namespace] || {};
  window[namespace].requestRules = [];
  window[namespace].responseRules = [];
  window[namespace].redirectRules = [];
  window[namespace].replaceRules = [];
  let isDebugMode = false;

  // Some frames are sandboxes and throw DOMException when accessing localStorage
  try {
    isDebugMode = window && window.localStorage && localStorage.isDebugMode;
  } catch (e) {}

  const isExtensionEnabled = () => {
    return window[namespace].isExtensionEnabled ?? true;
  };

  const getAbsoluteUrl = (url) => {
    const dummyLink = document.createElement("a");
    dummyLink.href = url;
    return dummyLink.href;
  };

  const isNonJsonObject = (obj) => {
    return [
      Blob,
      ArrayBuffer,
      Object.getPrototypeOf(Uint8Array), // TypedArray instance type
      DataView,
      FormData,
      URLSearchParams,
    ].some((nonJsonType) => obj instanceof nonJsonType);
  };

  /**
   * @param {Object} json
   * @param {String} path -> "a", "a.b", "a.0.b (If a is an array containing list of objects"
   * Also copied in shared/utils.js for the sake of testing
   */
  const traverseJsonByPath = (jsonObject, path) => {
    if (!path) return;

    const pathParts = path.split(".");

    try {
      // Reach the last node but not the leaf node.
      for (i = 0; i < pathParts.length - 1; i++) {
        jsonObject = jsonObject[pathParts[i]];
      }

      return jsonObject[pathParts[pathParts.length - 1]];
    } catch (e) {
      /* Do nothing */
    }
  };

  const matchesSourceFilters = ({ requestData, method }, sourceFilters) => {
    const sourceFiltersArray = Array.isArray(sourceFilters) ? sourceFilters : [sourceFilters];

    return (
      !sourceFiltersArray.length ||
      sourceFiltersArray.some((sourceFilter) => {
        if (sourceFilter?.requestMethod?.length && !sourceFilter.requestMethod.includes(method)) {
          return false;
        }

        let requestPayloadFilter = sourceFilter?.requestPayload;

        if (!requestPayloadFilter) return true;
        if (typeof requestPayloadFilter === "object" && Object.keys(requestPayloadFilter).length === 0) return true;

        // We only allow request payload targeting when requestData is JSON
        if (!requestData || typeof requestData !== "object") return false;
        if (Object.keys(requestData).length === 0) return false;

        requestPayloadFilter = requestPayloadFilter || {};
        const targetedKey = requestPayloadFilter?.key;
        const targetedValue = requestPayloadFilter?.value;

        // tagetedKey is the json path e.g. a.b.0.c
        if (targetedKey && typeof targetedValue !== undefined) {
          const valueInRequestData = traverseJsonByPath(requestData, targetedKey);
          const operator = requestPayloadFilter?.operator;

          if (!operator || operator === "Equals") {
            return valueInRequestData === targetedValue;
          }

          if (operator === "Contains") {
            return valueInRequestData.includes(targetedValue);
          }
        }

        return false;
      })
    );
  };

  const matchRuleSource = ({ url, requestData, method }, rule) => {
    const modification = rule.pairs[0];
    const ruleSource = modification.source;

    return (
      window[namespace].matchSourceUrl(ruleSource, url) &&
      matchesSourceFilters({ requestData, method }, ruleSource?.filters)
    );
  };

  const getRequestRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].requestRules?.findLast((rule) =>
      window[namespace].matchSourceUrl(rule.pairs[0].source, url)
    );
  };

  const getResponseRule = ({ url, requestData, method }) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].responseRules?.findLast((rule) => {
      return matchRuleSource({ url, requestData, method }, rule);
    });
  };

  const getMatchingRedirectRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].redirectRules?.findLast((rule) =>
      rule.pairs.some((pair) => window[namespace].matchSourceUrl(pair.source, url))
    );
  };

  const getMatchingReplaceRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].replaceRules?.findLast((rule) =>
      rule.pairs.some((pair) => window[namespace].matchSourceUrl(pair.source, url))
    );
  };

  const shouldServeResponseWithoutRequest = (responseRule) => {
    const responseModification = responseRule.pairs[0].response;
    return responseModification.type === "static" && responseModification.serveWithoutRequest;
  };

  const getFunctionFromCode = (code) => {
    return new Function("args", `return (${code})(args);`);
  };

  const getCustomRequestBody = (requestRule, args) => {
    const modification = requestRule.pairs[0].request;
    if (modification.type === "static") {
      requestBody = modification.value;
    } else {
      requestBody = getFunctionFromCode(modification.value)(args);
    }

    if (typeof requestBody !== "object" || isNonJsonObject(requestBody)) {
      return requestBody;
    }

    return JSON.stringify(requestBody);
  };

  /**
   * @param mightBeJSONString string which might be JSON String or normal String
   * @param doStrictCheck should return empty JSON if invalid JSON string
   */
  const jsonifyValidJSONString = (mightBeJSONString, doStrictCheck) => {
    const defaultValue = doStrictCheck ? {} : mightBeJSONString;

    if (typeof mightBeJSONString !== "string") {
      return defaultValue;
    }

    try {
      return JSON.parse(mightBeJSONString);
    } catch (e) {
      /* Do Nothing. Unable to parse the param value */
    }

    return defaultValue;
  };

  const isJSON = (data) => {
    const parsedJson = jsonifyValidJSONString(data);
    return parsedJson !== data; // if data is not a JSON, jsonifyValidJSONString() returns same value
  };

  const notifyRequestRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "request_rule_applied",
        id: message.ruleDetails.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const notifyResponseRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "response_rule_applied",
        id: message.rule.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const isPromise = (obj) =>
    !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";

  const isContentTypeJSON = (contentType) => !!contentType?.includes("application/json");

  // Intercept XMLHttpRequest
  const onReadyStateChange = async function () {
    if (this.readyState === this.HEADERS_RECEIVED || this.readyState === this.DONE) {
      if (!this.responseRule) {
        return;
      }

      const responseModification = this.responseRule.pairs[0].response;
      const responseType = this.responseType;
      const contentType = this.getResponseHeader("content-type");

      isDebugMode &&
        console.log("RQ", "Inside the XHR onReadyStateChange block for url", {
          url: this.requestURL,
          xhr: this,
        });

      if (this.readyState === this.HEADERS_RECEIVED) {
        // For network failures, responseStatus=0 but we still return customResponse with status=200
        const responseStatus = parseInt(responseModification.statusCode || this.status) || 200;
        const responseStatusText = responseModification.statusText || this.statusText;

        Object.defineProperty(this, "status", {
          get: () => responseStatus,
        });

        Object.defineProperty(this, "statusText", {
          get: () => responseStatusText,
        });
      }

      if (this.readyState === this.DONE) {
        let customResponse =
          responseModification.type === "code"
            ? getFunctionFromCode(responseModification.value)({
                method: this.method,
                url: this.requestURL,
                requestHeaders: this.requestHeaders,
                requestData: jsonifyValidJSONString(this.requestData),
                responseType: contentType,
                response: this.response,
                responseJSON: jsonifyValidJSONString(this.response, true),
              })
            : responseModification.value;

        // Convert customResponse back to rawText
        // response.value is String and evaluator method might return string/object
        if (isPromise(customResponse)) {
          customResponse = await customResponse;
        }

        const isUnsupportedResponseType = responseType && !["json", "text"].includes(responseType);

        // We do not support statically modifying responses of type - blob, arraybuffer, document etc.
        if (responseModification.type === "static" && isUnsupportedResponseType) {
          customResponse = this.response;
        }

        if (
          !isUnsupportedResponseType &&
          typeof customResponse === "object" &&
          !(customResponse instanceof Blob) &&
          (responseType === "json" || isContentTypeJSON(contentType))
        ) {
          customResponse = JSON.stringify(customResponse);
        }

        Object.defineProperty(this, "response", {
          get: function () {
            if (responseModification.type === "static" && responseType === "json") {
              if (typeof customResponse === "object") {
                return customResponse;
              }

              return jsonifyValidJSONString(customResponse);
            }

            return customResponse;
          },
        });

        if (responseType === "" || responseType === "text") {
          Object.defineProperty(this, "responseText", {
            get: function () {
              return customResponse;
            },
          });
        }

        const requestDetails = {
          url: this.requestURL,
          method: this.method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        };

        notifyResponseRuleApplied({
          rule: this.responseRule,
          requestDetails,
        });
      }
    }
  };

  const resolveXHR = (xhr, responseData) => {
    Object.defineProperty(xhr, "readyState", { writable: true });
    const updateReadyState = (readyState) => {
      xhr.readyState = readyState;
      xhr.dispatchEvent(new CustomEvent("readystatechange"));
    };
    const dispatchProgressEvent = (type) => {
      xhr.dispatchEvent(new ProgressEvent(type));
    };

    dispatchProgressEvent("loadstart");

    // update response headers
    const contentType = isJSON(responseData) ? "application/json" : "text/plain";
    xhr.getResponseHeader = (key) => {
      if (key.toLowerCase() === "content-type") {
        return contentType;
      }
      return null;
    };
    updateReadyState(xhr.HEADERS_RECEIVED);

    // mark resolved
    updateReadyState(xhr.DONE);
    dispatchProgressEvent("load");
    dispatchProgressEvent("loadend");
  };

  const XHR = XMLHttpRequest;
  XMLHttpRequest = function () {
    const xhr = new XHR();
    xhr.addEventListener("readystatechange", onReadyStateChange.bind(xhr), false);
    return xhr;
  };
  XMLHttpRequest.prototype = XHR.prototype;
  Object.entries(XHR).map(([key, val]) => {
    XMLHttpRequest[key] = val;
  });

  const open = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function (method, url) {
    this.method = method;
    this.requestURL = getAbsoluteUrl(url);
    open.apply(this, arguments);
  };

  const send = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function (data) {
    this.requestData = data;

    const requestRule = getRequestRule(this.requestURL);
    if (requestRule) {
      this.requestData = getCustomRequestBody(requestRule, {
        method: this.method,
        url: this.requestURL,
        body: data,
        bodyAsJson: jsonifyValidJSONString(data, true),
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url: this.requestURL,
          method: this.method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        },
      });
    }

    this.responseRule = getResponseRule({
      url: this.requestURL,
      requestData: jsonifyValidJSONString(this.requestData),
      method: this.method,
    });

    if (this.responseRule && shouldServeResponseWithoutRequest(this.responseRule)) {
      resolveXHR(this, this.responseRule.pairs[0].response.value);
    } else {
      send.call(this, this.requestData);
    }
  };

  let setRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
    this.requestHeaders = this.requestHeaders || {};
    this.requestHeaders[header] = value;
    setRequestHeader.apply(this, arguments);
  };

  // Intercept fetch API
  const _fetch = fetch;
  fetch = async (...args) => {
    const [resource, initOptions = {}] = args;
    const getOriginalResponse = () => _fetch(...args);

    let request;

    if (resource instanceof Request) {
      request = resource.clone();
    } else {
      request = new Request(resource.toString(), initOptions);
    }

    let hasModifiedHeaders = false;

    const url = getAbsoluteUrl(request.url);
    const method = request.method;

    const redirectRuleThatMatchesURL = getMatchingRedirectRule(url);
    const replaceRuleThatMatchesURL = getMatchingReplaceRule(url);

    // redirect/replace rule specific code that is applied only when redirect/replace rule matches the URL
    if (redirectRuleThatMatchesURL || replaceRuleThatMatchesURL) {
      // Stores Auth header to be set on redirected URL. Refer: https://github.com/requestly/requestly/issues/1208
      ignoredHeadersOnRedirect.forEach((header) => {
        const originalHeaderValue = request.headers.get(header);
        if (isExtensionEnabled() && originalHeaderValue) {
          hasModifiedHeaders = true;
          request.headers.set(customHeaderPrefix + header, originalHeaderValue);
        }
      });
    }

    // Request body can be sent only for request methods other than GET and HEAD.
    const canRequestBodyBeSent = !["GET", "HEAD"].includes(method);

    const requestRule = canRequestBodyBeSent && getRequestRule(url);
    if (requestRule) {
      const originalRequestBody = await request.text();
      const requestBody =
        getCustomRequestBody(requestRule, {
          method: request.method,
          url,
          body: originalRequestBody,
          bodyAsJson: jsonifyValidJSONString(originalRequestBody, true),
        }) || {};

      request = new Request(request.url, {
        method,
        body: requestBody,
        headers: request.headers,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url,
          method: request.method,
          type: "fetch",
          timeStamp: Date.now(),
        },
      });
    }

    let requestData;
    if (canRequestBodyBeSent) {
      requestData = jsonifyValidJSONString(await request.clone().text()); // cloning because the request will be used to make API call
    }

    const responseRule = getResponseRule({ url, requestData, method });
    let responseHeaders;
    let fetchedResponse;

    if (responseRule && shouldServeResponseWithoutRequest(responseRule)) {
      const contentType = isJSON(responseRule.pairs[0].response.value) ? "application/json" : "text/plain";
      responseHeaders = new Headers({ "content-type": contentType });
    } else {
      try {
        if (requestRule || hasModifiedHeaders) {
          // use modified request to fetch response
          fetchedResponse = await _fetch(request);
        } else {
          fetchedResponse = await getOriginalResponse();
        }

        if (!responseRule) {
          return fetchedResponse;
        }

        responseHeaders = fetchedResponse?.headers;
      } catch (error) {
        if (!responseRule) {
          return Promise.reject(error);
        }
      }
    }

    isDebugMode &&
      console.log("RQ", "Inside the fetch block for url", {
        url,
        resource,
        initOptions,
        fetchedResponse,
      });

    let customResponse;
    const responseModification = responseRule.pairs[0].response;

    if (responseModification.type === "code") {
      const requestHeaders =
        request.headers &&
        Array.from(request.headers).reduce((obj, [key, val]) => {
          obj[key] = val;
          return obj;
        }, {});

      let evaluatorArgs = {
        method,
        url,
        requestHeaders,
        requestData,
      };

      if (fetchedResponse) {
        const fetchedResponseData = await fetchedResponse.text();
        const responseType = fetchedResponse.headers.get("content-type");
        const fetchedResponseDataAsJson = jsonifyValidJSONString(fetchedResponseData, true);

        evaluatorArgs = {
          ...evaluatorArgs,
          responseType,
          response: fetchedResponseData,
          responseJSON: fetchedResponseDataAsJson,
        };
      }

      customResponse = getFunctionFromCode(responseModification.value)(evaluatorArgs);

      // evaluator might return us Object but response.value is string
      // So make the response consistent by converting to JSON String and then create the Response object
      if (isPromise(customResponse)) {
        customResponse = await customResponse;
      }

      if (typeof customResponse === "object" && isContentTypeJSON(evaluatorArgs?.responseType)) {
        customResponse = JSON.stringify(customResponse);
      }
    } else {
      customResponse = responseModification.value;
    }

    const requestDetails = {
      url,
      method,
      type: "fetch",
      timeStamp: Date.now(),
    };

    notifyResponseRuleApplied({
      rule: responseRule,
      requestDetails,
    });

    // For network failures, fetchedResponse is undefined but we still return customResponse with status=200
    const finalStatusCode = parseInt(responseModification.statusCode || fetchedResponse?.status) || 200;
    const requiresNullResponseBody = [204, 205, 304].includes(finalStatusCode);

    return new Response(requiresNullResponseBody ? null : new Blob([customResponse]), {
      status: finalStatusCode,
      statusText: responseModification.statusText || fetchedResponse?.statusText,
      headers: responseHeaders,
    });
  };
})({"namespace":"__REQUESTLY__","customHeaderPrefix":"x-rq-","ignoredHeadersOnRedirect":["Authorization"]})</script></head>
<body>

</body></html>